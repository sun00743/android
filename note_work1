----popWindow
popWindow.showAsDropDown(view) 在view的下方展开popwindow;
popWindow可以设置宽度

----List 转 数组
String[] packageArr = (String[])packageList.toArray(new String[packageList.size()]);

String[] array = (String[])List.toArray(new String[List.size()]);

----设置activity没有标题
requestWindowFeature(Window.FEATURE_NO_TITLE);

----设备屏幕密度
density = px/dp;
获取屏幕分辨率利用 DisplayMetrics
DisplayMetrics metrics = new DisplayMetrics();
getWindowManager.getDefultDisplay.getMetrics;
metrics.widthplex
metrics.heightplex

----控件设置xml背景属性
<selector>
<item name = "state:pressed = "true"  ?">
    <shape ..... >
        <solid color = ""/>
	<croners radio = "" />	 
	 others .......
    </shape ...> 
</item>
<ite.....
</selector>

----girdview
    Xml属性：
        android:columnWidth         设置列的宽度。   关联的方法为：setColumnWidth(int)
        android:horizontalSpacing   两列之间的间距。 关联方法：setHorizontalSpacing(int)
        android:numColumns          列数。           关联方法：setNumColumns(int)
        android:stretchMode         缩放模式。       关联方法：setStretchMode(int)
        android:verticalSpacing     两行之间的间距。 关联方法：setVerticalSpacing(int)

----自定义view
    1.想要padding生效，则要在ondraw方法中getpadding，然后在宽度中减去padding的值
    2.xml： res/values/attrs_xxxx.xml 
                <res...
                    <declare-styleable name="XXXX">
                        <attr name="" format="" />
                    </dec...
    3.format属性: reference  引用      @drawable/图片ID
                  string     字符串    
                  color      颜色      #00FF00
                  dimension  尺寸值    25dp/px 
                  integer    整形
                  float      浮点型    102.2
                  fraction   百分比    50%
                  
                  <attr name="orientation">    枚举  
                          <enum name="horizontal" value="0" />
                          <enum name="vertical" value="1" />
                  </attr>    
                  <attr name="windowSoftInputMode">   位或运算
                      <flag name = "stateUnspecified" value = "0" />
                      <flag name = "stateUnchanged" value = "1" />
    4.从xml资源中获取属性：
        TypeArray array = context.obtainStyledAttributes(attrs, R.styleable.XXXX);
        
----属性动画
    插值器
    1）AccelerateDecelerateInterpolator：先加速再减速。
    2）AccelerateInterpolator：一直加速。
    3）AnticipateInterpolator：先往后一下，再嗖的一声一往无前。
    4）AnticipateOvershootInterpolator：先往后一下，再一直往前超过终点，再往回收一下。
    5）BounceInterpolator：最后像个小球弹几下。
    6）CycleInterpolator：重复几次，感觉就是环形进度条那种，具体我还没试过。
    7）DecelerateInterpolator：一直减速。
    8）LinearInterpolator：线性，这个就是我们上面讲到的很均匀的了。
    9）OvershootInterpolator：到了终点之后，超过一点，再往回走。有个参数可以定义，超过的力度。
    
    valueAnimator中ofobject方法，要实现TypeEvaluator，复写evaluate方法
        fraction = startvalue/endvalue ， 随着duration （startvalue -> endvalue）  
     
----bezier曲线
    B(t) = P0*(1-t)^3 + 3*P1*t*(1-t)^2 + 3*P2*t^2*(1-t) + P3*t^3
    
----

 




public Rect getFramingRectDp() {
		Point screenResolution = configManager.getScreenResolution();
		if (framingRect == null) {
			if (camera == null) {
				return null;
			}
			// int width = screenResolution.x * 3 / 4;
			// if (width < MIN_FRAME_WIDTH) {
			// width = MIN_FRAME_WIDTH;
			// } else if (width > MAX_FRAME_WIDTH) {
			// width = MAX_FRAME_WIDTH;
			// }
			// int height = screenResolution.y * 3 / 4;
			// if (height < MIN_FRAME_HEIGHT) {
			// height = MIN_FRAME_HEIGHT;
			// } else if (height > MAX_FRAME_HEIGHT) {
			// height = MAX_FRAME_HEIGHT;
			// }
			// px 转换成 dp 进行计算
			int w = (int) (screenResolution.x / DensityUtils.getDsy(context));
			int h = (int) (screenResolution.y / DensityUtils.getDsy(context));
			int rw = 200;
			int rh = 190;
			int leftOffset = (w - rw) / 2;
			int topOffset = (h - rh) / 2;

			//绘制扫描正方形时转换为px
			framingRect = new Rect(DensityUtils.dp2px(context, leftOffset),
					DensityUtils.dp2px(context, topOffset), 
					DensityUtils.dp2px(context, leftOffset + rw),
					DensityUtils.dp2px(context, topOffset + rh));
			Log.d(TAG, "Calculated framing rect: " + framingRect);
		}
		return framingRect;
	}










